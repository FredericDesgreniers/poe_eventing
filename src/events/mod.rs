use failure::Error;
use io_watch::poll::Poller;
use regex::{Captures, Regex};

/// Manages events generated by a Poller that outputs strings
/// This takes events in the form of regex patterns + closure callbacks
/// Incoming strings can be processed by filters beforehand
pub struct EventManager<T: Poller<Output = String>> {
    poll: T,
    registered_events: Vec<Event>,
    filters: Vec<Box<Fn(String) -> String>>,
}

impl<T: Poller<Output = String>> EventManager<T> {
    /// Creates a new EventManager given a Poller of Strings
    pub fn new(poll: T) -> Self {
        Self {
            poll,
            registered_events: Vec::new(),
            filters: Vec::new(),
        }
    }

    /// Register a new event that can be called back when a matching string is found
    pub fn register_event(
        &mut self,
        pattern: &str,
        callback: impl Fn(Captures) + 'static,
    ) -> Result<(), Error> {
        self.registered_events.push(Event::new(pattern, callback)?);
        Ok(())
    }

    /// Register a filter to preprocess strings before finding the matching events
    pub fn register_filter(&mut self, filter: impl Fn(String) -> String + 'static) {
        self.filters.push(Box::new(filter));
    }

    //TODO: Find a good way to cancel this infinite loop

    /// Run event manager.
    /// This will only return on Error
    pub fn run(&mut self) -> Result<!, Error> {
        loop {
            let strings_to_process = self.poll.wait_and_read()?;

            strings_to_process
                .into_iter()
                .map(|mut string| {
                    for filter in &self.filters {
                        string = (*filter)(string);
                    }
                    string
                })
                .for_each(|string| {
                    self.registered_events.iter().for_each(|event| {
                        if let Some(captures) = event.regex.captures(&string) {
                            let callback = &*event.callback;

                            callback(captures);
                        };
                    })
                });
        }
    }
}

struct Event {
    regex: Regex,
    callback: Box<Fn(Captures)>,
}

impl Event {
    pub fn new(pattern: &str, callback: impl Fn(Captures) + 'static) -> Result<Self, Error> {
        Ok(Self {
            regex: Regex::new(pattern)?,
            callback: Box::new(callback),
        })
    }
}
